<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ToDo (Simplest)</title>
    <style>
      :root {
        /* Dark theme */
        --bg: #0b1220; /* ページ背景（濃紺） */
        --card: #0f172a; /* カード背景（slate-900系） */
        --text: #e5e7eb; /* 文字（明るめ） */
        --muted: #9ca3af; /* 補助文字 */
        --line: #1f2937; /* 枠線 */
        --accent: #60a5fa; /* アクセント（青） */
        --ok: #34d399; /* 成功 */
        --danger: #f87171; /* エラー */
        --shadow: 0 1px 2px rgba(0, 0, 0, 0.35), 0 14px 32px rgba(2, 6, 23, 0.6);
        --radius: 14px;
      }

      body {
        margin: 0;
        font: 16px/1.6 system-ui, -apple-system, "Segoe UI", Roboto,
          "Noto Sans JP", "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
        color: var(--text);
        background: radial-gradient(
            1200px 500px at 20% -10%,
            #1b2a44 0%,
            transparent 60%
          ),
          radial-gradient(1000px 400px at 90% 0%, #0e223b 0%, transparent 60%),
          linear-gradient(180deg, #0a1220 0%, #0b1220 100%);
      }

      .container {
        max-width: 920px;
        margin: 24px auto;
        padding: 0 16px;
      }

      header h1 {
        margin: 0;
        font-size: 22px;
        font-weight: 700;
        letter-spacing: 0.02em;
      }

      .input,
      .btn {
        border: 1px solid var(--line);
        background: #0b1528; /* 入力はやや明るい濃紺 */
        color: var(--text);
        padding: 10px 12px;
        border-radius: var(--radius);
      }
      .input::placeholder {
        color: #7c8696;
      }
      .input:focus,
      .input:focus-visible,
      textarea.input:focus,
      textarea.input:focus-visible {
        outline: none;
        border-color: #7fb4ff;
        box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.25);
      }

      .btn {
        cursor: pointer;
        transition: transform 0.15s, box-shadow 0.15s, opacity 0.15s;
      }
      .btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 10px 28px rgba(2, 6, 23, 0.45);
      }
      .btn.primary {
        color: #0b1220;
        background: linear-gradient(180deg, #93c5fd, #60a5fa);
        border-color: #93c5fd;
        box-shadow: 0 10px 28px rgba(96, 165, 250, 0.35);
      }

      .list {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      .row {
        background: var(--card);
        border: 1px solid var(--line);
        border-radius: var(--radius);
        padding: 10px 14px;
        box-shadow: var(--shadow);
        transition: transform 0.2s, box-shadow 0.2s;
        cursor: grab;
      }
      .row:hover {
        transform: translateY(-2px);
        box-shadow: 0 16px 40px rgba(2, 6, 23, 0.7);
      }

      .rowHead input[type="checkbox"] {
        width: 18px;
        height: 18px;
        accent-color: #7fb4ff;
      }

      .titleText {
        flex: 1;
        min-width: 0;
        font: 600 18px/1.5 inherit;
        color: var(--text);
        padding: 6px 0;
      }

      .muted {
        color: var(--muted);
        font-size: 12px;
      }

      .pill {
        font-size: 12px;
        padding: 2px 10px;
        border-radius: 999px;
        background: #0b1528;
        border: 1px solid var(--line);
        color: #cbd5e1;
      }
      .pill.done {
        color: #34d399;
        background: #0f1c17;
        border-color: #1f4739;
      }
      .pill.overdue {
        color: #fda4af;
        background: #2a1012;
        border-color: #5e1a21;
      }

      details > summary {
        font-size: 14px;
        color: #a0a9b8;
        cursor: pointer;
        user-select: none;
      }
      details[open] > summary {
        color: #93c5fd;
      }

      .panel {
        margin-top: 8px;
        padding: 12px;
        border: 1px solid var(--line);
        border-radius: calc(var(--radius) - 2px);
        background: #0b1528;
        display: grid;
        gap: 12px;
      }

      .panel input,
      .panel textarea,
      .panel select,
      .panel button {
        cursor: auto;
      }

      .quick {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }
      .chip {
        border: 1px solid var(--line);
        background: #0b1528;
        color: #d1d5db;
        padding: 6px 10px;
        border-radius: 999px;
        cursor: pointer;
      }
      .chip:hover {
        box-shadow: 0 6px 16px rgba(2, 6, 23, 0.55);
        transform: translateY(-1px);
      }
      .danger {
        color: #fecaca;
        border-color: #5e1a21;
        background: #2a1012;
      }

      /* DnDの見た目 */
      .row.dragging {
        opacity: 0.6;
        cursor: grabbing;
      }
      .row.drag-over {
        outline: 2px dashed #7fb4ff;
        outline-offset: 2px;
      }

      /* 並べ替えハンドル */
      .dragHandle {
        border: none;
        background: transparent;
        color: #93c5fd;
        cursor: grab;
        font-size: 18px;
        padding: 6px 8px;
        border-radius: 8px;
      }
      .dragHandle:active {
        cursor: grabbing;
      }
      /* 詳細メモの読みやすさアップ */
      textarea.input {
        padding: 14px 16px; /* 内側の余白を増やす */
        line-height: 1.9; /* 行間を広げる（デフォルト ~1.4〜1.6 よりゆったり） */
        font-size: 15px; /* 少し大きく */
        letter-spacing: 0.2px; /* 文字間にほんの少し余裕 */
        min-height: 140px; /* 初期の表示高さ */
        resize: vertical; /* 縦方向だけリサイズ可能 */
        box-sizing: border-box; /* padding を含めて高さ計算 */
        border-radius: calc(var(--radius) - 2px);
      }

      /* パネル内のレイアウトも少し広めに */
      .panel {
        gap: 14px;
      }
      .panel .grid {
        gap: 12px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>タスク</h1>
        <div class="new" style="flex: 1">
          <input id="newTitle" class="input" placeholder="新しいタスク…" />
          <button id="addBtn" class="btn primary">追加</button>
        </div>
      </header>

      <div id="list" class="list"></div>
    </div>

    <script>
      /* ====== 設定 ====== */
      const BASE =
        "https://wqwkh06vkl.execute-api.ap-northeast-3.amazonaws.com"; // 必要なら /Prod を付与

      /* ====== ユーティリティ ====== */
      const $ = (s, el = document) => el.querySelector(s);
      const el = (tag, attrs = {}) =>
        Object.assign(document.createElement(tag), attrs);
      const fmt = (iso) => {
        try {
          return new Date(iso).toLocaleString("ja-JP", {
            year: "numeric",
            month: "2-digit",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
          });
        } catch {
          return "";
        }
      };

      /* ====== 状態 ====== */
      let tasks = []; // 画面が持つタスク配列
      let dragSrcId = null; // いま掴んでいる行の task_id
      let dragGuard = false; // mousedown 判定で「このドラッグは禁止」

      /* ====== API ====== */
      async function api(path, opt = {}) {
        const init = { cache: "no-store", ...opt };
        if (init.body) {
          init.headers = {
            ...(init.headers || {}),
            "Content-Type": "application/json",
          };
        }
        const r = await fetch(BASE + path, init);
        if (!r.ok) throw new Error(await r.text());
        if (r.status === 204) return null; // 204は本文なし
        const ct = r.headers.get("content-type") || "";
        return ct.includes("application/json") ? r.json() : r.text();
      }
      const listTasks = () => api("/tasks");
      const createTask = (title) =>
        api("/tasks", { method: "POST", body: JSON.stringify({ title }) });
      const patchTask = (id, body) =>
        api(`/tasks/${id}`, { method: "PATCH", body: JSON.stringify(body) });
      const delTask = (id) => api(`/tasks/${id}`, { method: "DELETE" });

      /* ====== DnD（ドラッグ&ドロップ）補助 ====== */
      // 入力・ボタン・リンク・summary・.panel 内など “ドラッグ開始禁止” な場所判定
      function isInteractive(el) {
        return !!el.closest(
          "input, textarea, select, button, a, label, summary, .btn, .chip, .panel"
        );
      }
      // .panel 内でテキスト選択が存在するか
      function hasTextSelectionInPanel() {
        const sel = window.getSelection?.();
        if (!sel || sel.isCollapsed) return false;
        const n =
          sel.anchorNode &&
          (sel.anchorNode.nodeType === 1
            ? sel.anchorNode
            : sel.anchorNode.parentElement);
        return !!n?.closest?.(".panel");
      }
      // mousedown 時点で “掴んでよいか” を判断し、一時的に draggable を切り替え
      function guardDragByTarget(e) {
        dragGuard = isInteractive(e.target) || hasTextSelectionInPanel();
        this.draggable = !dragGuard; // 禁止なら行をドラッグ不可にして dragstart 自体を起こさない
      }
      function resetDragGuard() {
        dragGuard = false;
        this.draggable = true;
      }
      // 行の dragstart（最終チェック＆セットアップ）
      function onRowDragStart(e) {
        if (dragGuard || hasTextSelectionInPanel()) {
          e.preventDefault();
          return;
        }
        const r = e.currentTarget;
        dragSrcId = r.dataset.id;
        r.classList.add("dragging");
        const dt = e.dataTransfer;
        if (dt) {
          try {
            dt.setData("text/plain", dragSrcId);
          } catch {}
          dt.effectAllowed = "move";
        } // Safari対策
      }
      function onDragOver(e) {
        e.preventDefault(); // これが無いと drop が発火しない
        this.classList.add("drag-over");
        const dt = e.dataTransfer;
        if (dt) dt.dropEffect = "move";
      }
      function onDragLeave() {
        this.classList.remove("drag-over");
      }
      function onDrop(e) {
        e.preventDefault();
        this.classList.remove("drag-over");

        const dstId = this.dataset.id;
        if (!dragSrcId || dragSrcId === dstId) return;

        // 1) 配列内で入れ替え（楽観的更新）
        const from = tasks.findIndex((t) => t.task_id === dragSrcId);
        const to = tasks.findIndex((t) => t.task_id === dstId);
        if (from < 0 || to < 0) return;

        const moved = tasks.splice(from, 1)[0];
        tasks.splice(to, 0, moved);
        render();

        // 2) 並び順を保存（失敗時は戻す）
        persistNewSort(to).catch(() => {
          refresh();
          alert("並び替えの保存に失敗しました");
        });
      }
      function onDragEnd() {
        dragSrcId = null;
        document
          .querySelectorAll(".row.drag-over, .row.dragging")
          .forEach((el) => el.classList.remove("drag-over", "dragging"));
      }

      // 並び順保存：近傍の sort から “中間値” を付与
      async function persistNewSort(dropIndex) {
        const prev = tasks[dropIndex - 1]?.sort ?? null;
        const next = tasks[dropIndex + 1]?.sort ?? null;
        const cur = tasks[dropIndex];
        let newSort;

        if (prev == null && next == null) newSort = 0; // 要素が1件だけ
        else if (prev == null) newSort = Number(next) - 1; // 先頭に入った
        else if (next == null) newSort = Number(prev) + 1; // 末尾に入った
        else newSort = (Number(prev) + Number(next)) / 2; // 間に入った

        // 詰まり過ぎたら再採番
        if (
          !isFinite(newSort) ||
          (prev != null &&
            next != null &&
            Math.abs(Number(next) - Number(prev)) < 1e-6)
        ) {
          await reindexSorts();
          return;
        }

        cur.sort = newSort; // ローカルも更新
        await patchTask(cur.task_id, { sort: newSort }); // サーバ保存（Number→DynamoDBはサーバでDecimal変換）
      }

      // まとめて再採番（0,1000,2000,...）
      async function reindexSorts() {
        const step = 1000;
        const updates = [];
        tasks.forEach((t, i) => {
          const s = i * step;
          if (t.sort !== s) {
            t.sort = s;
            updates.push(patchTask(t.task_id, { sort: s }));
          }
        });
        if (updates.length) await Promise.all(updates);
      }

      /* ====== 描画 ====== */
      function render() {
        const list = $("#list");
        list.innerHTML = "";

        const roots = tasks.filter((t) => !t.parent_id); // 親だけ（サブタスク廃止）

        for (const it of roots) {
          const row = el("div", { className: "row" });
          row.dataset.id = it.task_id;
          row.dataset.sort = it.sort ?? 0;

          // どこでも掴めるが、入力や詳細の選択では発火しないようガード
          row.draggable = true;
          row.addEventListener("mousedown", guardDragByTarget);
          row.addEventListener("mouseup", resetDragGuard);
          row.addEventListener("mouseleave", resetDragGuard);
          row.addEventListener("dragstart", onRowDragStart);
          row.addEventListener("dragend", onDragEnd);

          row.addEventListener("dragover", onDragOver);
          row.addEventListener("dragleave", onDragLeave);
          row.addEventListener("drop", onDrop);

          // ヘッダ（チェック・タイトル表示専用・期日・バッジ）
          const head = el("div", { className: "rowHead" });

          const chk = el("input", { type: "checkbox" });
          chk.checked = it.status === "done";
          chk.onchange = async () => {
            await patchTask(it.task_id, {
              status: chk.checked ? "done" : "open",
            });
            await refresh();
          };

          const titleView = el("div", {
            className: "titleText",
            textContent: it.title,
          });

          const due = el("div", { className: "muted" });
          if (it.due_date) due.textContent = fmt(it.due_date);

          const badge = el("span", {
            className:
              "pill " +
              (it.status === "done" ? "done" : isOverdue(it) ? "overdue" : ""),
          });
          badge.textContent =
            it.status === "done" ? "完了" : isOverdue(it) ? "期限切れ" : "未";

          head.append(chk, titleView, due, badge);
          row.append(head);

          // 詳細パネル
          const det = el("details");
          const sum = el("summary");
          sum.textContent = "詳細を開く"; // 初期表示

          // ▼ 開閉状態に応じてラベルを変えるイベント
          det.addEventListener("toggle", () => {
            sum.textContent = det.open ? "詳細を閉じる" : "詳細を開く";
          });

          det.append(sum);

          const panel = el("div", { className: "panel" });
          // 詳細内の入力からの dragstart は無効化（保険）
          panel.addEventListener("dragstart", (e) => {
            if (
              e.target &&
              (e.target.tagName === "INPUT" ||
                e.target.tagName === "TEXTAREA" ||
                e.target.isContentEditable)
            ) {
              e.preventDefault();
              e.stopPropagation();
            }
          });

          // 2-0 タイトル編集（詳細を開いた時だけ）
          const tGrid = el("div", { className: "grid" });
          const titleEdit = el("input", {
            className: "input",
            value: it.title,
            placeholder: "タスク名",
          });
          titleEdit.setAttribute("draggable", "false");
          titleEdit.addEventListener("dragstart", (e) => e.preventDefault());
          const saveTitle = el("button", {
            className: "btn",
            textContent: "名前を保存",
          });
          saveTitle.onclick = async () => {
            const v = titleEdit.value.trim();
            if (!v || v === it.title) return;
            await patchTask(it.task_id, { title: v });
            titleView.textContent = v;
            it.title = v;
          };
          titleEdit.addEventListener("keydown", (e) => {
            if (e.key === "Enter") saveTitle.click();
          });
          tGrid.append(titleEdit, saveTitle);

          // 2-1 期日編集
          const dueGrid = el("div", { className: "grid" });
          const dueInput = el("input", {
            className: "input",
            type: "datetime-local",
          });
          dueInput.setAttribute("draggable", "false");
          dueInput.addEventListener("dragstart", (e) => e.preventDefault());
          if (it.due_date) {
            const d = new Date(it.due_date);
            dueInput.value = new Date(
              d.getTime() - d.getTimezoneOffset() * 60000
            )
              .toISOString()
              .slice(0, 16);
          }
          const saveDue = el("button", {
            className: "btn",
            textContent: "保存",
          });
          saveDue.onclick = async () => {
            const v = dueInput.value ? new Date(dueInput.value) : null;
            await patchTask(it.task_id, {
              due_date: v
                ? new Date(
                    v.getTime() + v.getTimezoneOffset() * 60000
                  ).toISOString()
                : null,
            });
            await refresh();
          };
          dueGrid.append(dueInput, saveDue);

          // 2-2 クイック期限
          const quick = el("div", { className: "quick" });
          [
            ["今日", endOf("today")],
            ["明日", endOf("tomorrow")],
            ["週末", endOf("weekend")],
            ["期限なし", null],
          ].forEach(([label, iso]) => {
            const c = el("button", { className: "chip", textContent: label });
            c.onclick = async () => {
              await patchTask(it.task_id, { due_date: iso });
              await refresh();
            };
            quick.append(c);
          });

          // 2-3 詳細メモ
          const memo = el("textarea", {
            className: "input",
            rows: 3,
            placeholder: "詳細",
            value: it.details || "",
          });
          memo.setAttribute("draggable", "false");
          memo.addEventListener("dragstart", (e) => e.preventDefault());

          /* ▼ 追加：最初に合わせ、以降は入力のたびに伸縮 */
          autoResizeTextarea(memo);
          memo.addEventListener("input", () => autoResizeTextarea(memo));

          memo.onchange = async () => {
            await patchTask(it.task_id, { details: memo.value || null });
          };

          // 2-4 危険操作
          const danger = el("div", { className: "quick" });
          if (it.status === "done") {
            const backBtn = el("button", {
              className: "chip",
              textContent: "未完に戻す",
            });
            backBtn.onclick = async () => {
              await patchTask(it.task_id, { status: "open" });
              await refresh();
            };
            danger.append(backBtn);
          }
          const delBtn = el("button", {
            className: "chip danger",
            textContent: "タスクを削除",
          });
          delBtn.onclick = async () => {
            if (!confirm("このタスクを削除しますか？")) return;
            const prev = tasks.slice();
            tasks = tasks.filter((t) => t.task_id !== it.task_id);
            render();
            try {
              await delTask(it.task_id);
            } catch {
              tasks = prev;
              render();
              alert("削除に失敗しました");
            }
          };
          danger.append(delBtn);

          panel.append(tGrid, dueGrid, quick, memo, danger);
          det.append(panel);
          row.append(det);
          list.append(row);
        }
      }

      // テキストエリアを内容に合わせて自動伸縮
      function autoResizeTextarea(el, max = 600) {
        el.style.height = "auto";
        el.style.height = Math.min(max, el.scrollHeight) + "px";
      }

      /* ====== 期限ヘルパ ====== */
      function endOf(kind) {
        const d = new Date();
        if (kind === "tomorrow") d.setDate(d.getDate() + 1);
        if (kind === "weekend") {
          const day = d.getDay();
          const diff = (6 - day + 7) % 7 || 0;
          d.setDate(d.getDate() + diff);
        }
        d.setHours(23, 59, 0, 0);
        return (
          new Date(d.getTime() - d.getTimezoneOffset() * 60000)
            .toISOString()
            .slice(0, 19) + "Z"
        );
      }
      function isOverdue(it) {
        return (
          it.due_date &&
          it.status !== "done" &&
          new Date(it.due_date) < new Date()
        );
      }

      /* ====== 追加：ボタン/Enter ====== */
      async function addNewTask() {
        const input = $("#newTitle");
        const t = input.value.trim();
        if (!t) return;
        await createTask(t);
        input.value = "";
        await refresh();
      }
      $("#addBtn").onclick = addNewTask;
      const titleInput = $("#newTitle");
      let composing = false;
      titleInput.addEventListener("compositionstart", () => (composing = true));
      titleInput.addEventListener("compositionend", () => (composing = false));
      titleInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !composing) {
          e.preventDefault();
          addNewTask();
        }
      });

      /* ====== 起動：初回は sort の初期採番も実施 ====== */
      async function refresh() {
        tasks = await listTasks();
        if (tasks.some((t) => t.sort == null)) {
          // sort が無いタスクがあれば一度だけ採番
          await reindexSorts();
          tasks = await listTasks(); // 採番後の最新を取り直す
        }
        render();
      }

      refresh();
    </script>
  </body>
</html>
