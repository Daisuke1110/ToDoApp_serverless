<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ToDo (Simplest)</title>
    <style>
      :root {
        --bg: #0b1220;
        --card: #0f172a;
        --text: #e5e7eb;
        --muted: #9ca3af;
        --line: #1f2937;
        --accent: #60a5fa;
        --ok: #34d399;
        --danger: #f87171;
        --shadow: 0 1px 2px rgba(0, 0, 0, 0.35), 0 14px 32px rgba(2, 6, 23, 0.6);
        --radius: 14px;
      }
      body {
        margin: 0;
        font: 16px/1.6 system-ui, -apple-system, "Segoe UI", Roboto,
          "Noto Sans JP", "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
        color: var(--text);
        background: radial-gradient(
            1200px 500px at 20% -10%,
            #1b2a44 0%,
            transparent 60%
          ),
          radial-gradient(1000px 400px at 90% 0%, #0e223b 0%, transparent 60%),
          linear-gradient(180deg, #0a1220 0%, #0b1220 100%);
      }
      .container {
        max-width: 920px;
        margin: 24px auto;
        padding: 0 16px;
      }
      header {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-bottom: 12px;
      }
      header h1 {
        margin: 0;
        font-size: 22px;
        font-weight: 700;
        letter-spacing: 0.02em;
      }
      .input,
      .btn {
        border: 1px solid var(--line);
        background: #0b1528;
        color: var(--text);
        padding: 10px 12px;
        border-radius: var(--radius);
      }
      .input::placeholder {
        color: #7c8696;
      }
      .input:focus,
      .input:focus-visible,
      textarea.input:focus,
      textarea.input:focus-visible {
        outline: none;
        border-color: #7fb4ff;
        box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.25);
      }
      .btn {
        cursor: pointer;
        transition: transform 0.15s, box-shadow 0.15s, opacity 0.15s;
      }
      .btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 10px 28px rgba(2, 6, 23, 0.45);
      }
      .btn.primary {
        color: #0b1220;
        background: linear-gradient(180deg, #93c5fd, #60a5fa);
        border-color: #93c5fd;
        box-shadow: 0 10px 28px rgba(96, 165, 250, 0.35);
      }
      .list {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      .row {
        background: var(--card);
        border: 1px solid var(--line);
        border-radius: var(--radius);
        padding: 10px 14px;
        box-shadow: var(--shadow);
        transition: transform 0.2s, box-shadow 0.2s;
        cursor: grab;
      }
      .row:hover {
        transform: translateY(-2px);
        box-shadow: 0 16px 40px rgba(2, 6, 23, 0.7);
      }
      .rowHead input[type="checkbox"] {
        width: 18px;
        height: 18px;
        accent-color: #7fb4ff;
      }
      .titleText {
        flex: 1;
        min-width: 0;
        font: 600 18px/1.5 inherit;
        color: var(--text);
        padding: 6px 0;
      }
      .muted {
        color: var(--muted);
        font-size: 12px;
      }
      .pill {
        font-size: 12px;
        padding: 2px 10px;
        border-radius: 999px;
        background: #0b1528;
        border: 1px solid var(--line);
        color: #cbd5e1;
      }
      .pill.done {
        color: #34d399;
        background: #0f1c17;
        border-color: #1f4739;
      }
      .pill.overdue {
        color: #fda4af;
        background: #2a1012;
        border-color: #5e1a21;
      }
      details > summary {
        font-size: 14px;
        color: #a0a9b8;
        cursor: pointer;
        user-select: none;
      }
      details[open] > summary {
        color: #93c5fd;
      }
      .panel {
        margin-top: 8px;
        padding: 12px;
        border: 1px solid var(--line);
        border-radius: calc(var(--radius) - 2px);
        background: #0b1528;
        display: grid;
        gap: 14px;
      }
      .panel .grid {
        gap: 12px;
      }
      .quick {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }
      .chip {
        border: 1px solid var(--line);
        background: #0b1528;
        color: #d1d5db;
        padding: 6px 10px;
        border-radius: 999px;
        cursor: pointer;
      }
      .chip:hover {
        box-shadow: 0 6px 16px rgba(2, 6, 23, 0.55);
        transform: translateY(-1px);
      }
      .danger {
        color: #fecaca;
        border-color: #5e1a21;
        background: #2a1012;
      }
      .row.dragging {
        opacity: 0.6;
        cursor: grabbing;
      }
      .row.drag-over {
        outline: 2px dashed #7fb4ff;
        outline-offset: 2px;
      }
      .dragHandle {
        border: none;
        background: transparent;
        color: #93c5fd;
        cursor: grab;
        font-size: 18px;
        padding: 6px 8px;
        border-radius: 8px;
      }
      .dragHandle:active {
        cursor: grabbing;
      }
      textarea.input {
        padding: 14px 16px;
        line-height: 1.9;
        font-size: 15px;
        letter-spacing: 0.2px;
        min-height: 140px;
        resize: vertical;
        box-sizing: border-box;
        border-radius: calc(var(--radius) - 2px);
      }
    </style>

    <!-- Amplify (UMD) を必ず自作スクリプトより前に読み込む -->
    <script src="/aws-amplify.min.js"></script>
  </head>

  <body>
    <div class="container">
      <header>
        <h1>タスク</h1>
        <div class="new" style="flex: 1">
          <input id="newTitle" class="input" placeholder="新しいタスク…" />
          <button id="addBtn" class="btn primary">追加</button>
        </div>
        <div
          id="auth"
          style="
            display: flex;
            gap: 8px;
            align-items: center;
            margin-left: 12px;
          "
        >
          <span id="who" class="muted">未ログイン</span>
          <button id="loginBtn" class="btn">ログイン</button>
          <button id="logoutBtn" class="btn" style="display: none">
            ログアウト
          </button>
        </div>
      </header>

      <div id="list" class="list"></div>
    </div>

    <script>
      /* ===== 認証：Cognito 設定 ===== */
      const HOSTED =
        "https://todopp-auth-daisuke1110.auth.ap-northeast-3.amazoncognito.com";
      const USER_POOL_ID = "ap-northeast-3_LDCubxc4m";
      const USER_POOL_CLIENT_ID = "1jev7trqkf0ekf3ksmhptsnabd";

      // API の起点 URL
      const BASE =
        "https://wqwkh06vkl.execute-api.ap-northeast-3.amazonaws.com";

      const Auth = aws_amplify.Auth;
      Auth.configure({
        region: "ap-northeast-3",
        userPoolId: USER_POOL_ID,
        userPoolWebClientId: USER_POOL_CLIENT_ID,
        oauth: {
          domain: new URL(HOSTED).host, // 例: xxx.auth.ap-northeast-3.amazoncognito.com
          scope: ["openid", "email"],
          redirectSignIn: window.location.origin + "/", // 完全一致させる
          redirectSignOut: window.location.origin + "/", // 完全一致させる
          responseType: "code",
        },
      });

      // v4/v6 どちらでも動くヘルパ
      async function fetchSessionSafe() {
        try {
          return Auth.fetchAuthSession
            ? await Auth.fetchAuthSession()
            : await Auth.currentSession();
        } catch {
          return null;
        }
      }
      async function getIdToken() {
        const s = await fetchSessionSafe();
        return (
          s?.tokens?.idToken?.toString?.() ??
          s?.getIdToken?.().getJwtToken?.() ??
          null
        );
      }
      async function getUserEmail() {
        try {
          if (Auth.getCurrentUser) {
            const u = await Auth.getCurrentUser();
            return u?.attributes?.email || u?.signInDetails?.loginId || null;
          }
          const u = await Auth.currentAuthenticatedUser();
          return u?.attributes?.email || null;
        } catch {
          return null;
        }
      }

      async function updateAuthUI() {
        const who = document.getElementById("who");
        const login = document.getElementById("loginBtn");
        const logout = document.getElementById("logoutBtn");
        const token = await getIdToken();
        if (token) {
          who.textContent = (await getUserEmail()) || "ログイン中";
          login.style.display = "none";
          logout.style.display = "";
        } else {
          who.textContent = "未ログイン";
          login.style.display = "";
          logout.style.display = "none";
        }
      }

      // ===== Amplify のローカルキャッシュ掃除 =====
      function clearAmplifyLocal() {
        try {
          const prefix = `CognitoIdentityServiceProvider.${USER_POOL_CLIENT_ID}`;
          Object.keys(localStorage)
            .filter((k) => k.startsWith(prefix) || k.startsWith("amplify-"))
            .forEach((k) => localStorage.removeItem(k));
        } catch {}
        try {
          Object.keys(sessionStorage)
            .filter((k) => k.startsWith("amplify-"))
            .forEach((k) => sessionStorage.removeItem(k));
        } catch {}
      }

      /* ===== 認証ボタン配線 ===== */
      const loginBtn = document.getElementById("loginBtn");
      const logoutBtn = document.getElementById("logoutBtn");

      loginBtn.onclick = () => Auth.federatedSignIn();

      // ★ 修正: logout_uri からフラグメント（#...）を排除し、事前にローカルキャッシュを削除
      logoutBtn.onclick = () => {
        clearAmplifyLocal(); // 先に端末側のトークンを消す
        const domain = new URL(HOSTED).host;
        const redirect = window.location.origin + "/"; // ← フラグメントなし
        const url = `https://${domain}/logout?client_id=${encodeURIComponent(
          USER_POOL_CLIENT_ID
        )}&logout_uri=${encodeURIComponent(redirect)}`;
        location.assign(url); // Hosted UI の /logout へ
      };

      /* ===== 共通ユーティリティ ===== */
      const $ = (s, el = document) => el.querySelector(s);
      const el = (tag, attrs = {}) =>
        Object.assign(document.createElement(tag), attrs);
      const fmt = (iso) => {
        try {
          return new Date(iso).toLocaleString("ja-JP", {
            year: "numeric",
            month: "2-digit",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
          });
        } catch {
          return "";
        }
      };
      function autoResizeTextarea(elm, max = 600) {
        elm.style.height = "auto";
        elm.style.height = Math.min(max, elm.scrollHeight) + "px";
      }

      /* ===== API（JWT付与） ===== */
      async function api(path, opt = {}) {
        const init = { cache: "no-store", ...opt };
        if (init.body)
          init.headers = {
            ...(init.headers || {}),
            "Content-Type": "application/json",
          };
        const token = await getIdToken();
        if (!token)
          throw new Error(
            "未ログインのためAPIを呼べません。右上の「ログイン」からサインインしてください。"
          );
        init.headers = {
          ...(init.headers || {}),
          Authorization: `Bearer ${token}`,
        };
        const r = await fetch(BASE + path, init);
        if (!r.ok) throw new Error(await r.text());
        if (r.status === 204) return null;
        const ct = r.headers.get("content-type") || "";
        return ct.includes("application/json") ? r.json() : r.text();
      }
      const listTasks = () => api("/tasks");
      const createTask = (title) =>
        api("/tasks", { method: "POST", body: JSON.stringify({ title }) });
      const patchTask = (id, body) =>
        api(`/tasks/${id}`, { method: "PATCH", body: JSON.stringify(body) });
      const delTask = (id) => api(`/tasks/${id}`, { method: "DELETE" });

      /* ===== DnD & 描画（元のまま） ===== */
      let tasks = [],
        dragSrcId = null,
        dragGuard = false;
      function isInteractive(elm) {
        return !!elm.closest(
          "input, textarea, select, button, a, label, summary, .btn, .chip, .panel"
        );
      }
      function hasTextSelectionInPanel() {
        const sel = window.getSelection?.();
        if (!sel || sel.isCollapsed) return false;
        const n =
          sel.anchorNode &&
          (sel.anchorNode.nodeType === 1
            ? sel.anchorNode
            : sel.anchorNode.parentElement);
        return !!n?.closest?.(".panel");
      }
      function guardDragByTarget(e) {
        dragGuard = isInteractive(e.target) || hasTextSelectionInPanel();
        this.draggable = !dragGuard;
      }
      function resetDragGuard() {
        dragGuard = false;
        this.draggable = true;
      }
      function onRowDragStart(e) {
        if (dragGuard || hasTextSelectionInPanel()) {
          e.preventDefault();
          return;
        }
        const r = e.currentTarget;
        dragSrcId = r.dataset.id;
        r.classList.add("dragging");
        const dt = e.dataTransfer;
        if (dt) {
          try {
            dt.setData("text/plain", dragSrcId);
          } catch {}
          dt.effectAllowed = "move";
        }
      }
      function onDragOver(e) {
        e.preventDefault();
        this.classList.add("drag-over");
        const dt = e.dataTransfer;
        if (dt) dt.dropEffect = "move";
      }
      function onDragLeave() {
        this.classList.remove("drag-over");
      }
      function onDrop(e) {
        e.preventDefault();
        this.classList.remove("drag-over");
        const dstId = this.dataset.id;
        if (!dragSrcId || dragSrcId === dstId) return;
        const from = tasks.findIndex((t) => t.task_id === dragSrcId);
        const to = tasks.findIndex((t) => t.task_id === dstId);
        if (from < 0 || to < 0) return;
        const moved = tasks.splice(from, 1)[0];
        tasks.splice(to, 0, moved);
        render();
        persistNewSort(to).catch(() => {
          refresh();
          alert("並び替えの保存に失敗しました");
        });
      }
      function onDragEnd() {
        dragSrcId = null;
        document
          .querySelectorAll(".row.drag-over,.row.dragging")
          .forEach((el) => el.classList.remove("drag-over", "dragging"));
      }
      async function persistNewSort(dropIndex) {
        const prev = tasks[dropIndex - 1]?.sort ?? null,
          next = tasks[dropIndex + 1]?.sort ?? null,
          cur = tasks[dropIndex];
        let newSort;
        if (prev == null && next == null) newSort = 0;
        else if (prev == null) newSort = Number(next) - 1;
        else if (next == null) newSort = Number(prev) + 1;
        else newSort = (Number(prev) + Number(next)) / 2;
        if (
          !isFinite(newSort) ||
          (prev != null &&
            next != null &&
            Math.abs(Number(next) - Number(prev)) < 1e-6)
        ) {
          await reindexSorts();
          return;
        }
        cur.sort = newSort;
        await patchTask(cur.task_id, { sort: newSort });
      }
      async function reindexSorts() {
        const step = 1000,
          updates = [];
        tasks.forEach((t, i) => {
          const s = i * step;
          if (t.sort !== s) {
            t.sort = s;
            updates.push(patchTask(t.task_id, { sort: s }));
          }
        });
        if (updates.length) await Promise.all(updates);
      }

      function render() {
        const list = $("#list");
        list.innerHTML = "";
        const roots = tasks.filter((t) => !t.parent_id);
        for (const it of roots) {
          const row = el("div", { className: "row" });
          row.dataset.id = it.task_id;
          row.dataset.sort = it.sort ?? 0;
          row.draggable = true;
          row.addEventListener("mousedown", guardDragByTarget);
          row.addEventListener("mouseup", resetDragGuard);
          row.addEventListener("mouseleave", resetDragGuard);
          row.addEventListener("dragstart", onRowDragStart);
          row.addEventListener("dragend", onDragEnd);
          row.addEventListener("dragover", onDragOver);
          row.addEventListener("dragleave", onDragLeave);
          row.addEventListener("drop", onDrop);

          const head = el("div", {
            className: "rowHead",
            style: "display:flex; align-items:center; gap:10px;",
          });
          const chk = el("input", { type: "checkbox" });
          chk.checked = it.status === "done";
          chk.onchange = async () => {
            await patchTask(it.task_id, {
              status: chk.checked ? "done" : "open",
            });
            await refresh();
          };
          const titleView = el("div", {
            className: "titleText",
            textContent: it.title,
          });
          const due = el("div", { className: "muted" });
          if (it.due_date) due.textContent = fmt(it.due_date);
          const badge = el("span", {
            className:
              "pill " +
              (it.status === "done" ? "done" : isOverdue(it) ? "overdue" : ""),
          });
          badge.textContent =
            it.status === "done" ? "完了" : isOverdue(it) ? "期限切れ" : "未";
          head.append(chk, titleView, due, badge);
          row.append(head);

          const det = el("details");
          const sum = el("summary");
          sum.textContent = "詳細を開く";
          det.addEventListener("toggle", () => {
            sum.textContent = det.open ? "詳細を閉じる" : "詳細を開く";
          });
          det.append(sum);

          const panel = el("div", { className: "panel" });
          panel.addEventListener("dragstart", (e) => {
            if (
              e.target &&
              (e.target.tagName === "INPUT" ||
                e.target.tagName === "TEXTAREA" ||
                e.target.isContentEditable)
            ) {
              e.preventDefault();
              e.stopPropagation();
            }
          });

          const tGrid = el("div", { className: "grid" });
          const titleEdit = el("input", {
            className: "input",
            value: it.title,
            placeholder: "タスク名",
          });
          titleEdit.setAttribute("draggable", "false");
          titleEdit.addEventListener("dragstart", (e) => e.preventDefault());
          const saveTitle = el("button", {
            className: "btn",
            textContent: "名前を保存",
          });
          saveTitle.onclick = async () => {
            const v = titleEdit.value.trim();
            if (!v || v === it.title) return;
            await patchTask(it.task_id, { title: v });
            titleView.textContent = v;
            it.title = v;
          };
          titleEdit.addEventListener("keydown", (e) => {
            if (e.key === "Enter") saveTitle.click();
          });
          tGrid.append(titleEdit, saveTitle);

          const dueGrid = el("div", { className: "grid" });
          const dueInput = el("input", {
            className: "input",
            type: "datetime-local",
          });
          dueInput.setAttribute("draggable", "false");
          dueInput.addEventListener("dragstart", (e) => e.preventDefault());
          if (it.due_date) {
            const d = new Date(it.due_date);
            dueInput.value = new Date(
              d.getTime() - d.getTimezoneOffset() * 60000
            )
              .toISOString()
              .slice(0, 16);
          }
          const saveDue = el("button", {
            className: "btn",
            textContent: "保存",
          });
          saveDue.onclick = async () => {
            const v = dueInput.value ? new Date(dueInput.value) : null;
            await patchTask(it.task_id, {
              due_date: v
                ? new Date(
                    v.getTime() + v.getTimezoneOffset() * 60000
                  ).toISOString()
                : null,
            });
            await refresh();
          };
          dueGrid.append(dueInput, saveDue);

          const quick = el("div", { className: "quick" });
          [
            ["今日", endOf("today")],
            ["明日", endOf("tomorrow")],
            ["週末", endOf("weekend")],
            ["期限なし", null],
          ].forEach(([label, iso]) => {
            const c = el("button", { className: "chip", textContent: label });
            c.onclick = async () => {
              await patchTask(it.task_id, { due_date: iso });
              await refresh();
            };
            quick.append(c);
          });

          const memo = el("textarea", {
            className: "input",
            rows: 3,
            placeholder: "詳細",
            value: it.details || "",
          });
          memo.setAttribute("draggable", "false");
          memo.addEventListener("dragstart", (e) => e.preventDefault());
          autoResizeTextarea(memo);
          memo.addEventListener("input", () => autoResizeTextarea(memo));
          memo.onchange = async () => {
            await patchTask(it.task_id, { details: memo.value || null });
          };

          const danger = el("div", { className: "quick" });
          if (it.status === "done") {
            const backBtn = el("button", {
              className: "chip",
              textContent: "未完に戻す",
            });
            backBtn.onclick = async () => {
              await patchTask(it.task_id, { status: "open" });
              await refresh();
            };
            danger.append(backBtn);
          }
          const delBtn = el("button", {
            className: "chip danger",
            textContent: "タスクを削除",
          });
          delBtn.onclick = async () => {
            if (!confirm("このタスクを削除しますか？")) return;
            const prev = tasks.slice();
            tasks = tasks.filter((t) => t.task_id !== it.task_id);
            render();
            try {
              await delTask(it.task_id);
            } catch {
              tasks = prev;
              render();
              alert("削除に失敗しました");
            }
          };
          danger.append(delBtn);

          panel.append(tGrid, dueGrid, quick, memo, danger);
          det.append(panel);
          row.append(det);
          list.append(row);
        }
        if (!tasks.length && $("#who").textContent === "未ログイン") {
          const empty = el("div", {
            className: "muted",
            style: "padding:8px 2px;",
          });
          empty.textContent = "右上の「ログイン」からサインインしてください。";
          list.append(empty);
        }
      }

      function endOf(kind) {
        const d = new Date();
        if (kind === "tomorrow") d.setDate(d.getDate() + 1);
        if (kind === "weekend") {
          const day = d.getDay();
          const diff = (6 - day + 7) % 7 || 0;
          d.setDate(d.getDate() + diff);
        }
        d.setHours(23, 59, 0, 0);
        return (
          new Date(d.getTime() - d.getTimezoneOffset() * 60000)
            .toISOString()
            .slice(0, 19) + "Z"
        );
      }
      function isOverdue(it) {
        return (
          it.due_date &&
          it.status !== "done" &&
          new Date(it.due_date) < new Date()
        );
      }

      /* ===== 起動（最初にトークン交換→UI→一覧） ===== */
      async function refresh() {
        await fetchSessionSafe(); // ?code の交換
        await updateAuthUI();
        const token = await getIdToken();
        if (!token) {
          tasks = [];
          render();
          return;
        }
        try {
          tasks = await listTasks();
          if (tasks.some((t) => t.sort == null)) {
            await reindexSorts();
            tasks = await listTasks();
          }
        } catch (e) {
          console.error(e);
          alert("APIエラー: " + (e?.message || e));
          tasks = [];
        }
        render();
      }

      // ★ 修正: signedout ハッシュ処理は不要。常に通常起動。
      window.addEventListener("DOMContentLoaded", async () => {
        await refresh();
      });

      // 新規追加
      document.getElementById("addBtn").onclick = async () => {
        const input = $("#newTitle");
        const t = input.value.trim();
        if (!t) return;
        await createTask(t);
        input.value = "";
        await refresh();
      };
      const titleInput = document.getElementById("newTitle");
      let composing = false;
      titleInput.addEventListener("compositionstart", () => (composing = true));
      titleInput.addEventListener("compositionend", () => (composing = false));
      titleInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !composing) {
          e.preventDefault();
          document.getElementById("addBtn").click();
        }
      });
    </script>
  </body>
</html>
